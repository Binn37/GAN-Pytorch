import os

import numpy as np
import torch

from PIL import Image
from torch.autograd import Variable
from torchvision.utils import save_image


def crop(path_input, path_output, heightCut, widthCut, border, count):
    """This just crop image into 9 images (3 class version)"""
    im = Image.open(path_input)
    img_width, img_height = im.size
    label = 0
    for i in range(2, img_height - 2, heightCut + border):
        for j in range(2, img_width - 2, widthCut + border):
            range_w = j + widthCut
            range_h = i + heightCut
            box = (j, i, range_w, range_h)
            print(box)
            tiled_img = im.crop(box)

            if label == 0:
                tiled_img.save(os.path.join(path_output, "Babuk_0", f"fake_{label}_{i}_{j}_{count}.png"))
            elif label == 1:
                tiled_img.save(os.path.join(path_output, "Cerber_1", f"fake_{label}_{i}_{j}_{count}.png"))
            elif label == 2:
                tiled_img.save(os.path.join(path_output, "Conti_2", f"fake_{label}_{i}_{j}_{count}.png"))
            elif label == 3:
                tiled_img.save(os.path.join(path_output, "GandCrab_3", f"fake_{label}_{i}_{j}_{count}.png"))
            elif label == 4:
                tiled_img.save(os.path.join(path_output, "Nitro_4", f"fake_{label}_{i}_{j}_{count}.png"))
            elif label == 5:
                tiled_img.save(os.path.join(path_output, "Ryuk_5", f"fake_{label}_{i}_{j}_{count}.png"))
            elif label == 6:
                tiled_img.save(os.path.join(path_output, "Stop_6", f"fake_{label}_{i}_{j}_{count}.png"))
            elif label == 7:
                tiled_img.save(os.path.join(path_output, "WannaCry_7", f"fake_{label}_{i}_{j}_{count}.png"))
                label = -1

            label += 1
            count += 1
            print(tiled_img)


def weights_init_normal(m):
    classname = m.__class__.__name__
    if classname.find("Conv") != -1:
        torch.nn.init.normal_(m.weight.data, 0.0, 0.02)
    elif classname.find("BatchNorm") != -1:
        torch.nn.init.normal_(m.weight.data, 1.0, 0.02)
        torch.nn.init.constant_(m.bias.data, 0.0)


def to_categorical(y, num_columns, FloatTensor=None):
    """Returns one-hot encoded Variable"""
    y_cat = np.zeros((y.shape[0], num_columns))
    y_cat[range(y.shape[0]), y] = 1.0

    return Variable(FloatTensor(y_cat))


def sample_image_v3_9(n_row, batches_done, generator, static_label, static_code, static_z, latent_dim=None,
                      FloatTensor=None, unique_dll_vals=None, unique_cs_vals=None):
    """Saves a grid of generated digits ranging from 0 to n_classes"""
    # Static sample
    latent_space = Variable(FloatTensor(np.random.normal(0, 1, (n_row ** 2, latent_dim))))
    static_sample = generator(latent_space, static_label, static_code)
    save_image(static_sample.data, "images/static/%d.png" % batches_done, nrow=n_row, normalize=True)

    # Get varied c1 and c2
    code_dll = np.eye(len(unique_dll_vals[0]))[np.random.choice(unique_dll_vals.shape[0], n_row ** 2)]
    code_cs = np.random.choice(unique_cs_vals, (n_row ** 2, 1))
    c1 = Variable(FloatTensor(np.hstack((code_dll, code_cs))))
    sample1 = generator(static_z, static_label, c1)
    save_image(sample1.data, "images/varying_c1/%d.png" % batches_done, nrow=n_row, normalize=True)


def sample_image(n_row, batches_done, generator, static_label, static_code, static_z, latent_dim=None,
                 FloatTensor=None):
    """Saves a grid of generated digits ranging from 0 to n_classes"""
    # Static sample
    latent_space = Variable(FloatTensor(np.random.normal(0, 1, (n_row ** 2, latent_dim))))
    static_sample = generator(latent_space, static_label, static_code)
    save_image(static_sample.data, "images/static/%d.png" % batches_done, nrow=n_row, normalize=True)

    # Get varied c1 and c2
    zeros = np.zeros((n_row ** 2, 1))
    c_varied = np.repeat(np.linspace(-1, 1, n_row)[:, np.newaxis], n_row, 0)
    c1 = Variable(FloatTensor(np.concatenate((c_varied, zeros), -1)))
    c2 = Variable(FloatTensor(np.concatenate((zeros, c_varied), -1)))
    sample1 = generator(static_z, static_label, c1)
    sample2 = generator(static_z, static_label, c2)
    save_image(sample1.data, "images/varying_c1/%d.png" % batches_done, nrow=n_row, normalize=True)
    save_image(sample2.data, "images/varying_c2/%d.png" % batches_done, nrow=n_row, normalize=True)

def sample_image_ac_gan(n_row, batches_done, FloatTensor, LongTensor, generator, latent_dim):
    """Saves a grid of generated digits ranging from 0 to n_classes"""
    # Sample noise
    z = Variable(FloatTensor(np.random.normal(0, 1, (n_row ** 2, latent_dim))))
    # Get labels ranging from 0 to n_classes for n rows
    labels = np.array([num for _ in range(n_row) for num in range(n_row)])
    labels = Variable(LongTensor(labels))
    gen_imgs = generator(z, labels)
    save_image(gen_imgs.data, "images/ac-sample/%d.png" % batches_done, nrow=n_row, normalize=True)


def get_size(param, width):
    pass


def getBinaryData(filename):
    pass


def createRGBImage(family_name, file_name, inx, width=None):
    """
    Create RGB image from 24 bit binary data 8bit Red, 8 bit Green, 8bit Blue
    :param family_name: family of image file
    :param file_name: name of malware
    :param inx: index of the loop create image
    """
    index = 0
    rgb_data = []

    # Read binary file
    binary_data = getBinaryData(file_name)

    if binary_data:

        # Create R,G,B pixels
        while index < len(binary_data):
            R = binary_data[index]
            G = binary_data[index]
            B = binary_data[index]
            index += 1
            rgb_data.append((R, G, B))

        size = get_size(len(rgb_data), width)
        save_file_format_name(family_name, file_name, rgb_data, size, 'RGB', inx)


def save_file_format_name(family_name, file_name, data, size, image_type, inx):
    """
    Create RGB image with name format
    :param family_name: family of image file
    :param file_name: name of malware
    :param data: data to convert to image
    :param size: size of image
    :param image_type: type image (RGB,...)
    :param inx: index of the loop create image
    """
    image = Image.new(image_type, size)
    image.putdata(data)

    # setup output file_name
    dir = "temp"
    # image_name = os.getcwd() + os.sep + dir + os.sep + str(float(time.time())) + ".png"
    image_name = f"{os.getcwd()}\\{dir}\\{family_name}_{inx}.png"
    print(image_name)

    os.makedirs(os.path.dirname(family_name), exist_ok=True)

    image.save(image_name)
    print('The file', image_name, 'saved.')

    return image_name


def min_max_scaler(data, min_value, max_value):
    data_std = (data - data.min(axis=0)) / (data.max(axis=0) - data.min(axis=0))
    scaled_data = data_std * (max_value - min_value) + min_value
    return scaled_data


def build_feature_code(scaled_cs_vals, code_dim, dll_value, checksum_value, unique_cs_vals, unique_dll_vals):
    feature_code = np.zeros((1, code_dim))
    checksum_val_id = np.where(unique_cs_vals == checksum_value)[0]
    for index in range(len(unique_dll_vals)):
        if unique_dll_vals[index] == dll_value:
            feature_code[0, index] = 1.0
            feature_code[0, -1] = scaled_cs_vals[checksum_val_id]
            break

    return feature_code
