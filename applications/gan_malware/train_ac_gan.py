import os

import numpy as np
import torch
import torchvision.transforms as transforms
from torch.autograd import Variable

from utils.wandb_helper import init_wandb, log_loss_models, generate_image
from config.config_core import cuda, FloatTensor, LongTensor
from config.config_params_v3 import Opt
from models.ac_gan_original import Generator, Discriminator
from utils import load_custom_dataset, load_image_dataset
from utils.helper import weights_init_normal, sample_image_ac_gan, to_categorical


def main(opt: Opt, version: int = 1):
    os.makedirs(f"images/ac_gan/{opt.img_size}/", exist_ok=True)
    os.makedirs("weights/", exist_ok=True)

    # config setting
    print(vars(opt))

    # Loss functions
    adversarial_loss = torch.nn.BCELoss()
    auxiliary_loss = torch.nn.CrossEntropyLoss()

    # Initialize generator and discriminator
    generator = Generator(opt)
    discriminator = Discriminator(opt)

    if cuda:
        print("We are using GPU for training models")
        generator.cuda()
        discriminator.cuda()
        adversarial_loss.cuda()
        auxiliary_loss.cuda()

    # Initialize weights
    generator.apply(weights_init_normal)
    discriminator.apply(weights_init_normal)

    # Configure data loader
    os.makedirs(f"../data/dataset-v{version}/data", exist_ok=True)
    PATH_TO_GET_DATA = f"../data/dataset-v{version}/data"
    PATH_TO_GET_PE_FEATURES = f"../data/dataset-v{version}/classification_ransomware_family.xlsx"
    transform = transforms.Compose(
        [transforms.Resize(opt.img_size),
         transforms.CenterCrop(opt.img_size),
         transforms.ToTensor(),
         transforms.Grayscale(),
         transforms.Normalize([0.5], [0.5])]
    )

    data_read = load_custom_dataset.ImageLoader(annotations_file=PATH_TO_GET_PE_FEATURES, root=PATH_TO_GET_DATA,
                                                transform=transform)
    data_loader = load_image_dataset.load_dataset(dataset_read=data_read, batch_size=opt.batch_size, shuffle="true")

    # Optimizers
    optimizer_G = torch.optim.Adam(generator.parameters(), lr=opt.lr, betas=(opt.b1, opt.b2))
    optimizer_D = torch.optim.Adam(discriminator.parameters(), lr=opt.lr, betas=(opt.b1, opt.b2))

    # Static generator inputs for sampling
    static_z = Variable(FloatTensor(np.zeros((opt.n_classes ** 2, opt.latent_dim))))
    static_label = to_categorical(
        y=np.array([num for _ in range(opt.n_classes) for num in range(opt.n_classes)]),
        num_columns=opt.n_classes,
        FloatTensor=FloatTensor
    )

    # Upload wandb to log data
    init_wandb(name_project=f"AC-GAN-Mal-V{version}-{opt.img_size}-{opt.n_epochs}", entity="walter03",
               generator=generator, discriminator=discriminator, opt=opt)

    # ----------
    #  Training
    # ----------

    for epoch in range(opt.n_epochs):
        for i, (imgs, labels, _) in enumerate(data_loader):

            batch_size = imgs.shape[0]

            # Adversarial ground truths
            valid = Variable(FloatTensor(batch_size, 1).fill_(1.0), requires_grad=False)
            fake = Variable(FloatTensor(batch_size, 1).fill_(0.0), requires_grad=False)

            # Configure input
            real_imgs = Variable(imgs.type(FloatTensor))
            labels = Variable(labels.type(LongTensor))

            # -----------------
            #  Train Generator
            # -----------------

            optimizer_G.zero_grad()

            # Sample noise and labels as generator input
            z = Variable(FloatTensor(np.random.normal(0, 1, (batch_size, opt.latent_dim_ac))))
            gen_labels = Variable(LongTensor(np.random.randint(0, opt.n_classes, batch_size)))

            # Generate a batch of images
            gen_imgs = generator(z, gen_labels)

            # Loss measures generator's ability to fool the discriminator
            validity, pred_label = discriminator(gen_imgs)
            g_loss = 0.5 * (adversarial_loss(validity, valid) + auxiliary_loss(pred_label, gen_labels))

            g_loss.backward()
            optimizer_G.step()

            # ---------------------
            #  Train Discriminator
            # ---------------------

            optimizer_D.zero_grad()

            # Loss for real images
            real_pred, real_aux = discriminator(real_imgs)
            d_real_loss = (adversarial_loss(real_pred, valid) + auxiliary_loss(real_aux, labels)) / 2

            # Loss for fake images
            fake_pred, fake_aux = discriminator(gen_imgs.detach())
            d_fake_loss = (adversarial_loss(fake_pred, fake) + auxiliary_loss(fake_aux, gen_labels)) / 2

            # Total discriminator loss
            d_loss = (d_real_loss + d_fake_loss) / 2

            # Calculate discriminator accuracy
            pred = np.concatenate([real_aux.data.cpu().numpy(), fake_aux.data.cpu().numpy()], axis=0)
            gt = np.concatenate([labels.data.cpu().numpy(), gen_labels.data.cpu().numpy()], axis=0)
            d_acc = 100 * np.mean(np.argmax(pred, axis=1) == gt)

            d_loss.backward()
            optimizer_D.step()

            print(
                "[Epoch %d/%d] [Batch %d/%d] [D loss: %f, acc: %d%%] [G loss: %f]"
                % (epoch, opt.n_epochs, i, len(data_loader), d_loss.item(), d_acc, g_loss.item())
            )

            log_loss_models(d_loss=d_loss.item(), g_loss=g_loss.item(), d_acc=d_acc)

            if g_loss.item() <= opt.best_loss:
                torch.save(generator.state_dict(),
                           f'weights/generator_V{version}_{epoch}_{opt.n_epochs}_best_{opt.img_size}px.pt')

            batches_done = epoch * len(data_loader) + i
            if batches_done % opt.sample_interval == 0:
                sample_image_ac_gan(n_row=opt.n_classes, batches_done=batches_done, latent_dim=opt.latent_dim_ac,
                                    generator=generator, FloatTensor=FloatTensor, LongTensor=LongTensor,
                                    img_size=opt.img_size)

        generate_image(n_row=opt.n_classes, epoch_index=epoch, generator=generator, static_label=static_label,
                       static_z=static_z, FloatTensor=FloatTensor, opt=opt, is_only_static=True, is_ac_gan=True)

    torch.save(generator.state_dict(), f'weights/generator_V{version}_{opt.n_epochs}_{opt.img_size}px.pt')
    torch.save(discriminator.state_dict(), f'weights/discriminator_V{version}_{opt.n_epochs}_{opt.img_size}px.pt')

    generator_load = Generator(opt=opt)
    discriminator_load = Discriminator(opt=opt)
    generator_load.load_state_dict(torch.load(f'weights/generator_V{version}_{opt.n_epochs}_{opt.img_size}px.pt'))
    generator_load.eval()
    discriminator_load.load_state_dict(
        torch.load(f'weights/discriminator_V{version}_{opt.n_epochs}_{opt.img_size}px.pt'))
    discriminator_load.eval()

if __name__ == '__main__':
    size_image = input("Size of image training (32, 64, 128) (default: 32) : ")
    n_epochs = input("Number of epoch (default: 600) : ")
    opt = Opt()
    if size_image is not None or n_epochs is not None:
        opt.img_size = int(size_image or opt.img_size)
        opt.n_epochs = int(n_epochs or opt.n_epochs)

    main(opt)
