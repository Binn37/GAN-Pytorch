import os

import numpy as np
import torch
import torchvision.transforms as transforms
from torch.autograd import Variable

from applications.gan_malware.utils.wandb_helper import init_wandb, log_loss_models
from config.config_core import cuda, FloatTensor, LongTensor
from config.config_params_v3 import Opt
from models.ac_gan_original import Generator, Discriminator
from utils import load_custom_dataset, load_image_dataset
from utils.helper import weights_init_normal, sample_image_ac_gan


def main():
    os.makedirs("images/static/", exist_ok=True)
    os.makedirs("images/varying_c1/", exist_ok=True)
    os.makedirs("images/varying_c2/", exist_ok=True)
    os.makedirs("weights/", exist_ok=True)

    # config setting
    opt = Opt()
    print(vars(opt))

    # Loss functions
    adversarial_loss = torch.nn.BCELoss()
    auxiliary_loss = torch.nn.CrossEntropyLoss()

    # Initialize generator and discriminator
    generator = Generator(opt)
    discriminator = Discriminator(opt)

    if cuda:
        print("We are using GPU for training models")
        generator.cuda()
        discriminator.cuda()
        adversarial_loss.cuda()
        auxiliary_loss.cuda()

    # Initialize weights
    generator.apply(weights_init_normal)
    discriminator.apply(weights_init_normal)

    # Configure data loader
    os.makedirs("../data/dataset-v1/fixed-data", exist_ok=True)
    PATH_TO_GET_DATA = "../data/dataset-v1/fixed-data"
    PATH_TO_GET_PE_FEATURES = "../data/dataset-v1/classification_ransomware_family.xlsx"
    transform = transforms.Compose(
        [transforms.Resize(opt.img_size_32),
         transforms.CenterCrop(opt.img_size_32),
         transforms.ToTensor(),
         transforms.Grayscale(),
         transforms.Normalize([0.5], [0.5])]
    )

    data_read = load_custom_dataset.ImageLoader(annotations_file=PATH_TO_GET_PE_FEATURES, root=PATH_TO_GET_DATA, transform=transform)
    data_loader = load_image_dataset.load_dataset(dataset_read=data_read, batch_size=opt.batch_size, shuffle="true")

    # Optimizers
    optimizer_G = torch.optim.Adam(generator.parameters(), lr=opt.lr, betas=(opt.b1, opt.b2))
    optimizer_D = torch.optim.Adam(discriminator.parameters(), lr=opt.lr, betas=(opt.b1, opt.b2))

    # Upload wandb to log data
    init_wandb(name_project=f"AC-GAN-Mal-V3-{opt.n_epochs}.1", entity="walter03", generator=generator,
               discriminator=discriminator, opt=opt)

    # ----------
    #  Training
    # ----------

    for epoch in range(opt.n_epochs):
        for i, (imgs, labels, _) in enumerate(data_loader):

            batch_size = imgs.shape[0]

            # Adversarial ground truths
            valid = Variable(FloatTensor(batch_size, 1).fill_(1.0), requires_grad=False)
            fake = Variable(FloatTensor(batch_size, 1).fill_(0.0), requires_grad=False)

            # Configure input
            real_imgs = Variable(imgs.type(FloatTensor))
            labels = Variable(labels.type(LongTensor))

            # -----------------
            #  Train Generator
            # -----------------

            optimizer_G.zero_grad()

            # Sample noise and labels as generator input
            z = Variable(FloatTensor(np.random.normal(0, 1, (batch_size, opt.latent_dim_ac))))
            gen_labels = Variable(LongTensor(np.random.randint(0, opt.n_classes, batch_size)))

            # Generate a batch of images
            gen_imgs = generator(z, gen_labels)

            # Loss measures generator's ability to fool the discriminator
            validity, pred_label = discriminator(gen_imgs)
            g_loss = 0.5 * (adversarial_loss(validity, valid) + auxiliary_loss(pred_label, gen_labels))

            g_loss.backward()
            optimizer_G.step()

            # ---------------------
            #  Train Discriminator
            # ---------------------

            optimizer_D.zero_grad()

            # Loss for real images
            real_pred, real_aux = discriminator(real_imgs)
            d_real_loss = (adversarial_loss(real_pred, valid) + auxiliary_loss(real_aux, labels)) / 2

            # Loss for fake images
            fake_pred, fake_aux = discriminator(gen_imgs.detach())
            d_fake_loss = (adversarial_loss(fake_pred, fake) + auxiliary_loss(fake_aux, gen_labels)) / 2

            # Total discriminator loss
            d_loss = (d_real_loss + d_fake_loss) / 2

            # Calculate discriminator accuracy
            pred = np.concatenate([real_aux.data.cpu().numpy(), fake_aux.data.cpu().numpy()], axis=0)
            gt = np.concatenate([labels.data.cpu().numpy(), gen_labels.data.cpu().numpy()], axis=0)
            d_acc = np.mean(np.argmax(pred, axis=1) == gt)

            d_loss.backward()
            optimizer_D.step()

            print(
                "[Epoch %d/%d] [Batch %d/%d] [D loss: %f, acc: %d%%] [G loss: %f]"
                % (epoch, opt.n_epochs, i, len(data_loader), d_loss.item(), 100 * d_acc, g_loss.item())
            )

            log_loss_models(d_loss=d_loss.item(), g_loss=g_loss.item())
            if g_loss.item() <= opt.best_loss:
                torch.save(generator.state_dict(), f'weights/generator_V3_{epoch}_{opt.n_epochs}_best_32px.pt')

            batches_done = epoch * len(data_loader) + i
            if batches_done % opt.sample_interval == 0:
                sample_image_ac_gan(n_row=opt.n_classes, batches_done=batches_done, latent_dim=opt.latent_dim_ac, generator=generator,
                                    FloatTensor=FloatTensor, LongTensor=LongTensor)

if __name__ == '__main__':
    main()