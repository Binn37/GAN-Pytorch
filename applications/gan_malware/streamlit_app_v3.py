import random

import numpy as np
import streamlit as st
import torch
import torchvision.transforms as transforms
from PIL import Image
from torch.autograd import Variable
from torchvision.utils import make_grid, save_image

from config.config_core import cuda, FloatTensor
from config.config_params_v3 import Opt
from utils.helper import min_max_scaler
from utils.load_custom_dataset import ImageLoader


# Ensure that load_pg_gan_model is called only once, when the app first loads.
@st.experimental_singleton()
def load_gan_model(_opt: Opt, generator_path: str, discriminator_path: str, Generator, Discriminator):
    generator = Generator(opt=_opt)
    discriminator = Discriminator(opt=_opt)
    # print(cuda)
    if cuda:
        print("We are using GPU for generate fake data")
        generator.cuda()

    generator.load_state_dict(torch.load(generator_path))
    generator.eval()
    discriminator.load_state_dict(torch.load(discriminator_path))
    discriminator.eval()

    return generator, discriminator


def show_images_custom_option(chosen_class_idx, dll_value, checksum_value, generator, samples=None,
                              pe_features=None, code_dim=None, unique_cs_vals=None, unique_dll_vals=None, size=None,
                              latent_dim=None, n_classes=None):
    # get similar sample links
    similar_sample_links = []
    for sample in samples:
        if sample[1] == chosen_class_idx:
            similar_sample_links.append(sample[0])

        if sample[1] > chosen_class_idx:
            break

    # get pe features of sample
    in_path = random.choice(similar_sample_links)
    sample_name = in_path.split("\\")[-1]
    sample_name = sample_name.split(".")[0]
    pe_features_sample = pe_features[pe_features['legitimate'].str.contains(sample_name)]
    dll_value_sample = int(pe_features_sample["DllCharacteristics"].values[0])
    checksum_value_sample = int(pe_features_sample["CheckSum"].values[0])

    # build feature code for generator
    feature_code = Variable(FloatTensor(np.zeros((1, code_dim))))
    scaled_cs_vals = min_max_scaler(unique_cs_vals, -2, 2)
    checksum_val_id = np.where(unique_cs_vals == checksum_value)[0]
    for index in range(len(unique_dll_vals)):
        if unique_dll_vals[index] == dll_value:
            feature_code[0, index] = 1.0
            feature_code[0, -1] = Variable(FloatTensor(scaled_cs_vals[checksum_val_id]))
            break

    # print(f"unique_cs_vals: {unique_cs_vals}")
    # print(f"unique_dll_vals: {unique_dll_vals}")
    print(f"CUSTOM OPTION")
    print(f"path: {in_path}")
    print(f"dll_value: {dll_value}")
    print(f"checksum_value: {checksum_value}")
    print(f"feature_code: {feature_code}")

    # --------- #
    st.write("The images from original of a class to generated class")
    # LAYING OUT THE TOP SECTION OF THE APP
    row1, row2, row3 = st.columns(3)
    with row1:
        get_real_image(in_path)
        st.caption("PE Header of real ransomware")
        st.caption(f"DllCharacteristics: {dll_value_sample}")
        st.caption(f"CheckSum: {checksum_value_sample}")
    with row2:
        get_trained_image(in_path, size)
    with row3:
        generate_malware(chosen_class_idx, generator, latent_dim, n_classes, feature_code, 1)


def show_images_large_data(chosen_class_idx, generator, code_dim=None, unique_cs_vals=None, unique_dll_vals=None,
                           latent_dim=None, n_classes=None, num_image=None):
    feature_code = Variable(FloatTensor(np.zeros((num_image, code_dim))))
    dll_value = int(random.choice(unique_dll_vals))
    scaled_cs_vals = min_max_scaler(unique_cs_vals, -2, 2)
    checksum_value = int(random.choice(unique_cs_vals))
    checksum_val_id = np.where(unique_cs_vals == checksum_value)[0]
    print(f"dll_value: {dll_value}")
    print(f"checksum_value: {checksum_value}")
    for id_img in range(num_image):
        print(f"feature_code: {feature_code}")
        for dll_val_id in range(len(unique_dll_vals)):
            if unique_dll_vals[dll_val_id] == dll_value:
                feature_code[id_img, dll_val_id] = 1.0
                feature_code[id_img, -1] = Variable(FloatTensor(scaled_cs_vals[checksum_val_id]))
                break

    print(f"feature_code: {feature_code}")
    generate_malware(chosen_class_idx, generator, latent_dim, n_classes, feature_code, num_image)


# LABEL OPTION
def generate_malware(chosen_class_idx, generator, latent_dim, n_classes, feature_code, num_image):
    # Get label
    label_code = np.zeros((num_image, n_classes))
    label_code[range(num_image), chosen_class_idx] = 1.0
    print(f"chosen_class_idx: {chosen_class_idx}")
    print(f"label_code: {label_code}")
    print("-------------------------")
    label = Variable(FloatTensor(label_code))
    # Get latent space
    latent_space = Variable(FloatTensor(np.random.normal(0, 1, (num_image, latent_dim))))
    # Generate image
    static_sample = generator(latent_space, label, feature_code)
    # Setup data to show
    data_convert = static_sample.data.cpu().detach().numpy()
    # [-1,1] => [0,255]
    images = np.clip(np.rint((data_convert + 1.0) / 2.0 * 255.0), 0.0, 255.0).astype(np.uint8)
    # NCHW => NHWC
    images = images.transpose(0, 2, 3, 1)
    if(data_convert.shape[0] > 1):
        save_image(static_sample.data, "images/demo-app.png", nrow=int(np.sqrt(num_image)), normalize=True)
        image = Image.open('images/demo-app.png')
        st.image(image, caption="Generated Image")
    else:
        st.image(images[0], caption="Generated Image", use_column_width="always")


def get_trained_image(in_path, size):
    img = Image.open(in_path)
    img = img.resize((size, size), Image.Resampling.BICUBIC)
    st.image(img, caption="Image for training", use_column_width="always")


def get_real_image(in_path):
    img = Image.open(in_path)
    st.image(img, caption="Real Image", use_column_width="always")


def show_images_label_option(chosen_class_idx, generator, latent_dim, code_dim, n_classes, samples, size, pe_features,
                             unique_dll_vals, unique_cs_vals):
    # get similar sample links
    similar_sample_links = []
    for sample in samples:
        if sample[1] == chosen_class_idx:
            similar_sample_links.append(sample[0])

        if sample[1] > chosen_class_idx:
            break

    # get pe features of sample
    in_path = random.choice(similar_sample_links)
    sample_name = in_path.split("\\")[-1]
    sample_name = sample_name.split(".")[0]
    pe_features_sample = pe_features[pe_features['legitimate'].str.contains(sample_name)]

    # build feature code for generator
    feature_code = Variable(FloatTensor(np.zeros((1, code_dim))))
    dll_value = int(pe_features_sample["DllCharacteristics"].values[0])
    scaled_cs_vals = min_max_scaler(unique_cs_vals, -2, 2)
    checksum_value = int(pe_features_sample["CheckSum"].values[0])
    checksum_val_id = np.where(unique_cs_vals == checksum_value)[0]
    for index in range(len(unique_dll_vals)):
        if unique_dll_vals[index] == dll_value:
            feature_code[0, index] = 1.0
            feature_code[0, -1] = Variable(FloatTensor(scaled_cs_vals[checksum_val_id]))
            break

    print(f"LABEL OPTION")
    print(f"path: {in_path}")
    print(f"dll_value: {dll_value}")
    print(f"checksum_value: {checksum_value}")
    print(f"feature_code: {feature_code}")

    # --------- #
    st.write("The images from original of a class to generated class")
    # LAYING OUT THE TOP SECTION OF THE APP
    row1, row2, row3 = st.columns(3)
    with row1:
        get_real_image(in_path)
    with row2:
        get_trained_image(in_path, size)
    with row3:
        generate_malware(chosen_class_idx, generator, latent_dim, n_classes, feature_code, 1)


# END LABEL OPTION

@st.experimental_singleton()
def load_data_example(_opt: Opt, PATH_TO_GET_PE_FEATURES, PATH_TO_GET_DATA, size_image):
    if size_image == 32:
        transform = transforms.Compose(
            [transforms.Resize(_opt.img_size_32),
             transforms.CenterCrop(_opt.img_size_32),
             transforms.ToTensor(),
             transforms.Grayscale(),
             transforms.Normalize([0.5], [0.5])]
        )
    elif size_image == 64:
        transform = transforms.Compose(
            [transforms.Resize(_opt.img_size_64),
             transforms.CenterCrop(_opt.img_size_64),
             transforms.ToTensor(),
             transforms.Grayscale(),
             transforms.Normalize([0.5], [0.5])]
        )
    else:
        transform = transforms.Compose(
            [transforms.Resize(_opt.img_size_128),
             transforms.CenterCrop(_opt.img_size_128),
             transforms.ToTensor(),
             transforms.Grayscale(),
             transforms.Normalize([0.5], [0.5])]
        )

    data_read = ImageLoader(annotations_file=PATH_TO_GET_PE_FEATURES, root=PATH_TO_GET_DATA, transform=transform)
    return data_read


@st.experimental_singleton()
def get_specified_info(_data_reader):
    classes = _data_reader.classes
    classes_index = _data_reader.class_to_idx
    samples = _data_reader.samples
    pe_features = _data_reader.pe_features
    return classes, classes_index, samples, pe_features


@st.experimental_singleton()
def get_pe_features_info(_pe_features):
    unique_dll_vals = _pe_features["DllCharacteristics"].unique()
    unique_cs_vals = _pe_features["CheckSum"].unique()
    return unique_dll_vals, unique_cs_vals


@st.experimental_singleton()
def get_dll_val_per_class(_pe_features, classes):
    dll_per_label = []
    for name_class in classes:
        filtered_sample = _pe_features[_pe_features['legitimate'].str.contains(name_class)]
        dll_per_label.append(filtered_sample["DllCharacteristics"].unique())

    return dll_per_label


@st.experimental_singleton()
def get_cs_val_per_class(_pe_features, classes):
    cs_per_label = []
    for name_class in classes:
        filtered_sample = _pe_features[_pe_features['legitimate'].str.contains(name_class)]
        cs_per_label.append(filtered_sample["CheckSum"].unique())

    return cs_per_label


def main(size_image: int):
    st.title("Info-GAN Ransomware Demo")
    """This demo demonstrates using Info GAN model to generate ransomware. For more information, check out my 
    repo on [PyTorch-GAN-Ransomware](https://github.com/WalterDUT/PyTorch-GAN-Malware)."""

    opt = Opt()
    if size_image == 32:
        from models.info_gan_original import Generator, Discriminator
        PATH_GET_G = "weights/generator_V3_1000_32px.pt"
        PATH_GET_D = "weights/discriminator_V3_1000_32px.pt"
    elif size_image == 64:
        PATH_GET_G = "weights/generator_V3_1000_64px.pt"
        PATH_GET_D = "weights/discriminator_V3_1000_64px.pt"
        from models.info_gan_v64 import Generator, Discriminator
    else:
        PATH_GET_G = "weights/generator_V3_1000_128px.pt"
        PATH_GET_D = "weights/discriminator_V3_1000_128px.pt"
        from models.info_gan_v128 import Generator, Discriminator

    # path to get data
    PATH_TO_GET_DATA = "../data/dataset-v2/fixed-data"
    PATH_TO_GET_PE_FEATURES = "../data/dataset-v2/classification_ransomware_family.xlsx"

    # Get models from the link.
    generator, discriminator = load_gan_model(_opt=opt, generator_path=PATH_GET_G, discriminator_path=PATH_GET_D,
                                              Generator=Generator, Discriminator=Discriminator)

    data_reader = load_data_example(opt, PATH_TO_GET_PE_FEATURES, PATH_TO_GET_DATA, size_image)
    classes, classes_index, samples, pe_features = get_specified_info(data_reader)
    unique_dll_vals, unique_cs_vals = get_pe_features_info(pe_features)
    unique_dll_vals_per_class = get_dll_val_per_class(pe_features, classes)
    unique_cs_vals_per_class = get_cs_val_per_class(pe_features, classes)

    # Sidebar
    st.sidebar.title("Options for features")
    option = st.sidebar.selectbox('How would you like to generate fake ransomware?',
                                  ('Label Class', 'Custom', 'Huge dataset'))

    st.sidebar.title("Features to generate")
    chosen_class = st.sidebar.selectbox('Label Ransomware?', options=classes, key="class")
    chosen_class_index = classes_index[chosen_class]
    if option == 'Custom':
        dll_characteristic_value = st.sidebar.selectbox('DllCharacteristic Value:',
                                                        unique_dll_vals_per_class[chosen_class_index], key='dll')
        checksum_value = st.sidebar.selectbox('CheckSum Value:', unique_cs_vals_per_class[chosen_class_index],
                                              key='checksum')
        st.sidebar.button("Generate!", key="generate",
                          on_click=show_images_custom_option(chosen_class_idx=chosen_class_index,
                                                             dll_value=dll_characteristic_value,
                                                             checksum_value=checksum_value,
                                                             unique_dll_vals=unique_dll_vals,
                                                             unique_cs_vals=unique_cs_vals, pe_features=pe_features,
                                                             code_dim=opt.code_dim, latent_dim=opt.latent_dim,
                                                             n_classes=opt.n_classes, generator=generator,
                                                             samples=samples, size=size_image))
    elif option == 'Huge dataset':
        num_data = st.sidebar.slider("How many data do you want to create?", min_value=2, max_value=100)
        st.sidebar.button("Generate!", key="generate",
                          on_click=show_images_large_data(chosen_class_idx=chosen_class_index, n_classes=opt.n_classes,
                                                          generator=generator,
                                                          unique_cs_vals=unique_cs_vals,
                                                          unique_dll_vals=unique_dll_vals, code_dim=opt.code_dim,
                                                          latent_dim=opt.latent_dim, num_image=num_data))
    else:
        st.sidebar.button("Generate!", key="generate",
                          on_click=show_images_label_option(chosen_class_idx=chosen_class_index, generator=generator,
                                                            code_dim=opt.code_dim, latent_dim=opt.latent_dim,
                                                            n_classes=opt.n_classes, samples=samples, size=size_image,
                                                            pe_features=pe_features, unique_cs_vals=unique_cs_vals,
                                                            unique_dll_vals=unique_dll_vals))

    # Insert user-controlled values from sliders into the feature vector.
    st.sidebar.title("Note")
    st.sidebar.write(
        """Playing with the sliders, you _will_ find **biases** that exist in this model."""
    )
    st.sidebar.write(
        """
        Apps like these that allow you to visually inspect model inputs help you find these biases so you can address 
        them in your model _before_ it's put into production.
        """
    )
    st.sidebar.caption(f"Streamlit version `{st.__version__}`")
    # end Sidebar


if __name__ == '__main__':
    st.sidebar.title("Size of image to generate")
    size_option = st.sidebar.selectbox('Size of image to generate? (unit: pixel)', (128, 64, 32))
    main(size_image=size_option)
