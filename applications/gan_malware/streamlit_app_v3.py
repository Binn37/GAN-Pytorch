import numpy as np
import streamlit as st
import torch
from PIL import Image
from torch.autograd import Variable

from utils.helper import to_categorical
from utils.load_custom_dataset import ImageLoader
from config.config_params_v3 import Opt
from config.config_core import cuda, FloatTensor
import torchvision.transforms as transforms


# Ensure that load_pg_gan_model is called only once, when the app first loads.
@st.experimental_singleton()
def load_gan_model(_opt: Opt, generator_path: str, discriminator_path: str, Generator, Discriminator):
    generator = Generator(opt=_opt)
    discriminator = Discriminator(opt=_opt)
    print(cuda)
    if cuda:
        print("We are using GPU for generate fake data")
        generator.cuda()

    generator.load_state_dict(torch.load(generator_path))
    generator.eval()
    discriminator.load_state_dict(torch.load(discriminator_path))
    discriminator.eval()

    return generator, discriminator


def generateMalwareCustom(chosen_class, dll_characteristic_value, checksum_value):
    pass


def generate_malware(chosen_class_idx, generator, latent_dim, code_dim, n_classes):
    y = np.zeros((1, n_classes))
    y[0, chosen_class_idx] = 1.0

    static_label = Variable(FloatTensor(y))
    static_code = Variable(FloatTensor(np.zeros((1, code_dim))))
    latent_space = Variable(FloatTensor(np.random.normal(0, 1, (1, latent_dim))))
    static_sample = generator(latent_space, static_label, static_code)
    data_convert = static_sample.data.cpu().detach().numpy()
    # [-1,1] => [0,255]
    images = np.clip(np.rint((data_convert + 1.0) / 2.0 * 255.0), 0.0, 255.0).astype(np.uint8)
    # NCHW => NHWC
    images = images.transpose(0, 2, 3, 1)
    st.image(images[0], caption="Generated Image", use_column_width="always")


def get_trained_image(chosen_class_idx, samples, size):
    for sample in samples:
        if sample[1] == chosen_class_idx:
            in_path = sample[0]
            img = Image.open(in_path)
            img = img.resize((size, size), Image.Resampling.BICUBIC)
            st.image(img, caption="Image for training", use_column_width="always")
            break


def get_real_image(chosen_class_idx, samples):
    for sample in samples:
        if sample[1] == chosen_class_idx:
            in_path = sample[0]
            img = Image.open(in_path)
            st.image(img, caption="Real Image", use_column_width="always")
            break


def get_images_to_show(chosen_class_idx, generator, latent_dim, code_dim, n_classes, samples, size):
    st.write("The images from original of a class to generated class")
    # LAYING OUT THE TOP SECTION OF THE APP
    row1, row2, row3 = st.columns(3)
    with row1:
        get_real_image(chosen_class_idx, samples)
    with row2:
        get_trained_image(chosen_class_idx, samples, size)
    with row3:
        generate_malware(chosen_class_idx, generator, latent_dim, code_dim, n_classes)


@st.experimental_singleton()
def load_data_example(_opt: Opt, PATH_TO_GET_PE_FEATURES, PATH_TO_GET_DATA, size_image):
    if size_image == 32:
        transform = transforms.Compose(
            [transforms.Resize(_opt.img_size_32),
             transforms.CenterCrop(_opt.img_size_32),
             transforms.ToTensor(),
             transforms.Grayscale(),
             transforms.Normalize([0.5], [0.5])]
        )
    elif size_image == 64:
        transform = transforms.Compose(
            [transforms.Resize(_opt.img_size_64),
             transforms.CenterCrop(_opt.img_size_64),
             transforms.ToTensor(),
             transforms.Grayscale(),
             transforms.Normalize([0.5], [0.5])]
        )
    else:
        transform = transforms.Compose(
            [transforms.Resize(_opt.img_size_128),
             transforms.CenterCrop(_opt.img_size_128),
             transforms.ToTensor(),
             transforms.Grayscale(),
             transforms.Normalize([0.5], [0.5])]
        )

    data_read = ImageLoader(annotations_file=PATH_TO_GET_PE_FEATURES, root=PATH_TO_GET_DATA, transform=transform)
    return data_read


def main(size_image: int):
    st.title("Info-GAN Malware Demo")
    """This demo demonstrates  using Info GAN model to generate ransomware malware. For more information, check out my 
    repo on [PyTorch-GAN-Malware](https://github.com/WalterDUT/PyTorch-GAN-Malware)."""

    opt = Opt()
    if size_image == 32:
        from models.info_gan_original import Generator, Discriminator
        PATH_GET_G = "weights/generator_V3_600_32px.pt"
        PATH_GET_D = "weights/discriminator_V3_600_32px.pt"
    elif size_image == 64:
        PATH_GET_G = "weights/generator_V3_600_64px.pt"
        PATH_GET_D = "weights/discriminator_V3_600_64px.pt"
        from models.info_gan_v64 import Generator, Discriminator
    else:
        PATH_GET_G = "weights/generator_V3_600_128px.pt"
        PATH_GET_D = "weights/discriminator_V3_600_128px.pt"
        from models.info_gan_v128 import Generator, Discriminator

    # path to get data
    PATH_TO_GET_DATA = "../data/dataset-v2/fixed-data"
    PATH_TO_GET_PE_FEATURES = "../data/dataset-v2/classification_ransomware_family.xlsx"

    # Get models from the link.
    generator, discriminator = load_gan_model(_opt=opt, generator_path=PATH_GET_G, discriminator_path=PATH_GET_D,
                                              Generator=Generator, Discriminator=Discriminator)

    data_reader = load_data_example(opt, PATH_TO_GET_PE_FEATURES, PATH_TO_GET_DATA, size_image)
    classes = data_reader.classes
    classes_index = data_reader.class_to_idx
    samples = data_reader.samples

    # Sidebar
    st.sidebar.title("Option to generate")
    option = st.sidebar.selectbox('How would you like to generate fake malware?', ('Label Class', 'Custom'))

    st.sidebar.title("Features to generate")
    if option == 'Custom':
        chosen_class = st.sidebar.selectbox('Label Malware?', options=classes, key="class")
        chosen_class_index = classes_index[chosen_class]
        dll_characteristics = []
        dll_characteristic_value = st.sidebar.selectbox('DllCharacteristic Value:', dll_characteristics, key='dll')
        checksums = []
        checksum_value = st.sidebar.selectbox('DllCharacteristic Value:', checksums, key='checksum')
        st.sidebar.button("Generate!", key="generate",
                          on_click=generateMalwareCustom(chosen_class_index, dll_characteristic_value, checksum_value))
    else:
        chosen_class = st.sidebar.selectbox('Label Malware?', options=classes, key="class")
        chosen_class_index = classes_index[chosen_class]
        print("chosen_class: ", chosen_class_index)
        st.sidebar.button("Generate!", key="generate",
                          on_click=get_images_to_show(chosen_class_idx=chosen_class_index, generator=generator,
                                                      code_dim=opt.code_dim, latent_dim=opt.latent_dim,
                                                      n_classes=opt.n_classes, samples=samples, size=size_image))

    # Insert user-controlled values from sliders into the feature vector.
    st.sidebar.title("Note")
    st.sidebar.write(
        """Playing with the sliders, you _will_ find **biases** that exist in this model."""
    )
    st.sidebar.write(
        """
        Apps like these that allow you to visually inspect model inputs help you find these biases so you can address 
        them in your model _before_ it's put into production.
        """
    )
    st.sidebar.caption(f"Streamlit version `{st.__version__}`")
    # end Sidebar


if __name__ == '__main__':
    st.sidebar.title("Size Image to generate")
    size_option = st.sidebar.selectbox('Which size of image do you want to generate?', (32, 64, 128))
    main(size_image=size_option)
